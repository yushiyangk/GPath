"""
	GPath is a robust, generalised abstract file path that provides functions for common path manipulations independent from the local operating system.
"""

from __future__ import annotations

import functools
import os
import sys
from collections.abc import Collection, Iterator, Sequence
#from typing import Any, ClassVar, Final


# Type hinting prior to 3.10
# Using generics in built-in collections, e.g. list[int], is supported from 3.7 by __future__.annotations
from typing import Any, ClassVar, Optional, Union
if sys.version_info >= (3, 8):
	from typing import Final
else:
	Final = Any
if sys.version_info >= (3, 10):
	def _is_gpathlike(obj: Any) -> bool:
		return isinstance(obj, GPathLike)
else:
	def _is_gpathlike(obj: Any) -> bool:
		return isinstance(obj, GPath) or isinstance(obj, str) or isinstance(obj, os.PathLike)


__version__ = '0.3'


PATH_SEPARATOR: Final = "/" if os.sep == '/' or os.altsep == '/' else os.sep
PATH_CURRENT: Final = os.curdir
PATH_PARENT: Final = os.pardir

PathLike = Union[str, os.PathLike]


@functools.total_ordering
class GPath():
	"""
		A normalised and generalised abstract file path that has no dependency on the layout of any real filesystem. This allows us to manipulate file paths that were generated on a different system, particularly one with a different operating environment as compared to the local system.

		The path can be manipulated with various methods before being rendered in a format that is meaningful to the local operating system using `__str__()`.
	"""

	__slots__ = ('_parts', '_device', '_absolute', '_parent')

	separator: ClassVar[str] = PATH_SEPARATOR
	"""Path separator character, usually `/`"""

	current_dir: ClassVar[str] = PATH_CURRENT
	"""Path component that indicates the current directory; usually `.`"""

	parent_dir: ClassVar[str] = PATH_PARENT
	"""Path component that indicates a parent directory; usually `..`"""


	def __init__(self, path: Union[PathLike, GPath, None]=""):
		"""
			Initialise a normalised and generalised abstract file path, possibly by copying an existing GPath object.

			Parameters
			----------
			`path`
			: path-like object representing a (possibly unnormalised) file path, or a GPath object to be copied

			Raises
			------
			`ValueError` if `other` is an invalid GPath

			Examples
			--------
			```python
			GPath("/")
			GPath("/usr/bin")
			GPath("C:/Program Files")
			```
		"""
		self._parts: tuple[str, ...] = tuple()  # root- or parent- relative path
		self._device: str = ""
		self._absolute: bool = False
		self._parent: int = 0
		if path is not None and path != "":
			if isinstance(path, GPath):
				path._validate()
				self._parts = path._parts
				self._device = path._device
				self._absolute = path._absolute
				self._parent = path._parent
			else:
				# Remove redundant '.'s and '..'s and use OS-default path separators
				path = os.path.normpath(path)  # sets empty path to '.' and removes trailing slash

				if path == os.curdir:
					path = ""
				(self._device, path) = os.path.splitdrive(path)
				self._absolute = os.path.isabs(path)

				parts = path.split(os.sep)  # os.path.normpath previously rewrote the path to use os.sep
				if len(parts) > 0 and parts[0] == "":  # First element is '' if root
					parts = parts[1:]
				if len(parts) > 0 and parts[-1] == "":  # Last element is '' if there is a trailing slash, which should only happen when the path is exactly root ('/')
					parts = parts[:-1]

				dotdot = 0
				while dotdot < len(parts) and parts[dotdot] == GPath.parent_dir:  # GPath.parent_dir == '..' usually
					dotdot += 1
				self._parts = tuple(parts[dotdot:])
				self._parent = dotdot


	@staticmethod
	def from_parts(parts: Sequence[str]) -> GPath:
		"""
			Create a GPath object from a sequence of strings, such as that generated by `get_parts()`.

			Note that unlike `GPath.join()`, this method expects each item in the sequence to be a single string representing a path component, without any separators. Absolute paths are represented in the same manner as returned by `get_parts()`.
		"""
		return GPath(GPath.separator.join(parts))


	@staticmethod
	def find_common(path1: GPathLike, path2: GPathLike, allow_current: bool=True, allow_parents: bool=False) -> Optional[GPath]:
		"""
			Find the longest common base path shared by the two paths, or return None if no such path exists.

			A common base path might not exist if one path is an absolute path while the other is a relative path, or if the two paths are in different filesystems (with different device names), or in other cases as controlled by the `allow_current` and `allow_parents` options.

			Parameters
			----------
			`path1`, `path2`
			: the paths to compare

			`allow_current`
			: whether two non-parent relative paths that do not share any components should be considered to have a common base path, namely the imaginary current working directory. For instance, `GPath.find_common("some/rel/path", "another/rel/path")` will return `GPath("")` if set to True, or return None if set to False.

			`allow_parents`
			: whether two relative paths that are relative to different levels of parent directories should be considered to have a common base path, which is the highest level of parent directory between the two paths. For instance, `GPath.find_common("../rel/to/parent", "../../rel/to/grandparent")` will return `GPath("../..")` if set to True, or return None if set to False. **Warning**: when set to True, given a higher level of parent directory as output, it may not be possible to find the relative path to one of the inputs (see `relpath_from()`); in most cases False is more appropriate.

			Returns
			-------
			`GPath`
			: the longest common base path, which may be empty, if it exists

			`None`
			: otherwise

			Raises
			------
			`ValueError` if either GPath is invalid

			Examples
			--------
			```python
			GPath.find_common("/usr/bin", "/usr/local/bin")               # GPath("/usr")
			GPath.find_common("C:/Windows/System32", "C:/Program Files")  # GPath("C:/")
			GPath.find_common("../Documents", "../Pictures")              # GPath("..")
			```
		"""
		if isinstance(path1, GPath):
			path1._validate()
		else:
			path1 = GPath(path1)
		if isinstance(path2, GPath):
			path2._validate()
		else:
			path2 = GPath(path2)

		if path1._device != path2._device:
			return None
		if path1._absolute != path2._absolute:
			return None

		if allow_parents:
			allow_current = True

		parts = []
		if path1._absolute:
			common_path = GPath()
			for part1, part2 in zip(path1._parts, path2._parts):
				if part1 == part2:
					parts.append(part1)
			common_path._absolute = True
			# dotdot must be 0
		else:
			if path1._parent != path2._parent:
				if not allow_parents:
					return None

				common_path = GPath()
				common_path._parent = max(path1._parent, path2._parent)
			else:
				common_path = GPath()
				common_path._parent = path1._parent
				for part1, part2 in zip(path1._parts, path2._parts):
					if part1 == part2:
						parts.append(part1)

		common_path._device = path1._device
		common_path._parts = tuple(parts)

		if not allow_current and not bool(common_path):
			if common_path != path1 or common_path != path2:
				return None
		return common_path

	@staticmethod
	def partition(*paths: Union[Collection[GPathLike], GPathLike], allow_current: bool=True, allow_parents: bool=False) -> dict[GPath, list[GPath]]:
		"""
			Partition a collection of paths based on shared common base paths such that each path belongs to one partition.

			For each partition, return a list of relative paths from the base path of that partition to each corresponding input path within that partition, unless `allow_parents` is True (see below). If the input collection is ordered, the output order is preserved within each partition. If the input collection contains duplicates, the corresponding output lists will as well.

			The number of partitions is minimised by merging partitions as much as possible, so that each partition represents the highest possible level base path. Two partitions can no longer be merged when there is no common base path between them, as determined by `GPath.find_common()`. This method takes the same optional arguments as `GPath.find_common()`, with the same default values.

			Parameters
			----------
			`paths: Collection[GPath | str | os.PathLike]` or `*paths: GPath | str | os.PathLike`
			: the paths to be partitioned, which can be given as either a list-like object or as variadic arguments

			`allow_current`
			: whether non-parent relative paths with no shared components should be considered to have a common base path (see `GPath.find_common()`)

			`allow_parents`
			: whether paths that are relative to different levels of parent directories should be considered to have a common base path (see `GPath.find_common()`). **Warning**: when set to True, the output lists for each partition are invalidated, and explicitly set to empty. This is because it is not possible in general to obtain a relative path from the base path to its members if the base path is a parent directory of a higher level than the member (see `relpath_from()`). This  option should be True if and only if the list of members in each partition are not of interest; in most cases False is more appropriate.

			Returns
			-------
			a dictionary that maps the common base path of each partition to a list of relative paths

			Raises
			------
			  `ValueError`
			  if any of the GPaths are invalid

			Examples
			--------
			```python
			GPath.partition("/usr/bin", "/usr/local/bin", "../../doc", "C:/Windows", "C:/Program Files")

			assert partitions == {
				GPath("/usr")      : [GPath("bin"), GPath("local")],
				GPath("../../doc") : [GPath("")],
				GPath("C:/")       : [GPath("Windows"), GPath("Program Files")],
			}
			```
		"""
		flattened_paths: list[GPathLike] = []
		for path_or_list in paths:
			if _is_gpathlike(path_or_list):
				flattened_paths.append(path_or_list)
			else:
				flattened_paths.extend(path_or_list)
		gpaths = [path if isinstance(path, GPath) else GPath(path) for path in flattened_paths]

		partition_map = {}
		if len(gpaths) > 0:
			if allow_parents == True:
				partition_map[gpaths[0]] = []
			else:
				partition_map[gpaths[0]] = [gpaths[0]]

		for path in gpaths[1:]:
			partition_found = False
			for partition in partition_map:
				candidate_common = GPath.find_common(partition, path, allow_current=allow_current, allow_parents=allow_parents)
				if candidate_common is not None:
					partition_found = True
					if candidate_common != partition:
						partition_map[candidate_common] = partition_map[partition]
						del partition_map[partition]
					if allow_parents == False:
						partition_map[candidate_common].append(path)
					break
			if not partition_found:
				if allow_parents == True:
					partition_map[path] = []
				else:
					partition_map[path] = [path]

		for partition, path_list in partition_map.items():
			partition_map[partition] = [path.subpath_from(partition) for path in path_list]

		return partition_map


	@staticmethod
	def join(*paths: Union[Collection[GPathLike], GPathLike]) -> GPath:
		"""
			Join a sequence of paths into a single path. Apart from the first item in the sequence, all subsequent paths should be relative paths and any absolute paths will be ignored.

			Parameters
			----------
			`paths`: `Collection[GPath | str | os.PathLike]` or `*paths: GPath | str | os.PathLike`
			: the paths to be combined, which can be given as either a list-like object or as variadic arguments

			Returns
			-------
			the combined path

			Raises
			------
			`ValueError` if any of the GPaths are invalid

			Examples
			--------
			```python
			GPath.join("usr", "local", "bin")          # GPath("usr/local/bin")
			GPath.join("/usr/local/bin", "../../bin")  # GPath("/usr/bin")
			GPath.join("C:/", "Windows")               # GPath("C:/Windows")
			```
		"""
		flattened_paths: list[GPathLike] = []
		for path_or_list in paths:
			if _is_gpathlike(path_or_list):
				flattened_paths.append(path_or_list)
			else:
				flattened_paths.extend(path_or_list)

		if len(flattened_paths) == 0:
			return GPath()

		combined_path = flattened_paths[0]
		if not isinstance(combined_path, GPath):
			combined_path = GPath(combined_path)
		for path in flattened_paths[1:]:
			combined_path = combined_path + path

		return combined_path


	def get_parts(self, root: bool=True, parent: bool=True) -> list[str]:
		"""
			Convert the path to a list of strings that unambiguously represents the given path.

			The list of strings is given in such a way that a valid path can be reconstructed as a single string using <code>GPath.separator.join(<var>g</var>.get_parts())</code>. By default, the list of strings represents the full input path, but this behaviour can be changed using the optional arguments.

			If it is an absolute path, the first item in the returned list will contain the device name if it exists, or be an empty string otherwise. If the path is the filesystem root exactly, the returned list will contain exactly two items, with the second being an empty string.

			If the path is relative to a parent directory, e.g. `../..`, each parent level will be given as a separate item in the returned list.

			Parameters
			----------
			`root`
			: whether to include any components that indicate the filesystem root or device name. If set to True, the returned list will represent an absolute path as described above if the input path is absolute. If set to False, the returned list will always represent a relative path.

			`parent`
			: whether to include any components that indicate parent directories for a relative path. If set to False, the returned list will always be either an absolute path or a path relative to the imaginary current working directory.

			Returns
			-------
			list of strings representing the path

			Examples
			--------
			```python
			GPath("usr/local/bin").get_parts()     # ["usr", "local", "bin"]
			GPath("/usr/bin").get_parts()          # ["", "usr", "bin"]
			GPath("C:/Program Files").get_parts()  # ["C:", "Program Files"]
			GPath("../../Documents").get_parts()   # ["..", "..", "Documents"]
			```
		"""
		if root and self._absolute:
			if len(self._parts) == 0:
				return [self._device, ""]

			base_parts = [self._device]

		elif parent and self._parent > 0:
			base_parts = self.get_parent_parts()

		else:
			if len(self._parts) == 0:
				# bool(self) == False
				return [GPath.current_dir]

			base_parts = []

		return base_parts + list(self._parts)


	def get_parent_parts(self) -> list[str]:
		"""
			Get a list of strings representing the parent directory that the path is relative to, if any.

			For each parent level, the returned list will contain one copy of `GPath.parent_dir`. If the path is not relative to a parent directory, the returned list will be empty.

			Examples
			--------
			```python
			GPath("../../Documents").get_parent_parts()  # ["..", ".."]
			GPath("usr/local/bin").get_parent_parts()    # []
			```
		"""
		return [GPath.parent_dir for i in range(self._parent)]

	def get_parent_level(self) -> int:
		"""
			Get the number of levels of parent directories that the path is relative to, which may be 0.tain one copy of `GPath.parent_dir`. If the path is not relative to a parent directory, the returned list will be empty.

			Examples
			--------
			```python
			GPath("../../Documents").get_parent_level()  # 2
			GPath("usr/local/bin").get_parent_level()    # 0
			```
		"""
		return self._parent

	def get_device(self) -> Optional[str]:
		"""
			Get the device name.

			Examples
			--------
			```python
			GPath("C:/Windows").get_device()       # "C:"
			GPath("/usr/bin").get_device()         # ""
			GPath("../../Documents").get_device()  # ""
			```
		"""
		return self._device

	def is_absolute(self) -> bool:
		"""
			Check if the path is an absolute path.

			Examples
			--------
			```python
			GPath("/").is_absolute()                # True
			GPath("C:/Windows").is_absolute()       # True
			GPath("local/bin").is_absolute()        # False
			GPath("../../Documents").is_absolute()  # False
			```
		"""
		return self._absolute

	def is_root(self) -> bool:
		"""
			Check if the path is exactly the root of the filesystem.

			Examples
			--------
			```python
			GPath("/").is_root()                # True
			GPath("C:/").is_root()              # True
			GPath("/usr/bin").is_root()         # False
			GPath("C:/Windows").is_root()       # False
			GPath("../../Documents").is_root()  # False
			```
		"""
		return self._absolute and len(self._parts) == 0


	def subpath_from(self, base: GPathLike) -> Optional[GPath]:
		"""
			Find the relative subpath from `base` to `self` if possible and if `base` contains `self`, or return None otherwise.

			None will also be returned if there are unknown components in the subpath from `base` to `self`. For instance, if `self` is relative to the parent directory while `base` is relative to the grandparent directory, the path from the grandparent directory `../..` to the parent directory `..` cannot be known.

			Similar to `relpath_from()`, but `self` must be a descendent of `base`.

			Parameters
			----------
			`base`
			: the base path that the relative subpath should start from

			Returns
			-------
			`GPath`
			: relative subpath from `base` to `self`, which may be empty, if it exists

			`None`
			: otherwise

			Raises
			------
			`ValueError` if either `self` or `base` is an invalid GPath

			Examples
			--------
			```python
			GPath("/usr/local/bin").subpath_from("/usr")      # GPath("local/bin")
			GPath("/usr/bin").subpath_from("/usr/local/bin")  # None
			GPath("/usr/bin").subpath_from("../Documents")    # None
			```
		"""
		if not isinstance(base, GPath):
			base = GPath(base)

		if GPath.find_common(self, base, allow_current=True, allow_parents=False) is not None and self in base:
			# If self._dotdot > base._dotdot, self is not in base, whereas if self._dotdot < base._dotdot, path from base to self's parent cannot be known
			base_length = len(base._parts)
			new_path = GPath()
			new_path._parts = self._parts[base_length:]  # () when self == base
			return new_path
		else:
			return None


	def relpath_from(self, origin: GPathLike) -> Optional[GPath]:
		"""
			Find the relative path from `origin` to `self` if possible, or return None otherwise.

			None will also be returned if there are unknown components in the relative path from `origin` to `self`. For instance, if `self` is relative to the parent directory while `base` base is relative to the grandparent directory, the path from the grandparent directory `../..` to the parent directory `..` cannot be known.

			Similar to `subpath_from()`, but `self` does not need to be a descendent of `origin`.

			Parameters
			----------
			`origin`
			: the origin that the relative path should start from

			Returns
			-------
			`GPath`
			: relative path from `origin` to `self`, which may be empty, if it exists

			`None`
			: otherwise

			Raises
			------
			`ValueError` if either `self` or `origin` is an invalid GPath

			Examples
			--------
			```python
			GPath("/usr/local/bin").subpath_from("/usr")      # GPath("local/bin")
			GPath("/usr/bin").subpath_from("/usr/local/bin")  # GPath("../../bin")
			GPath("/usr/bin").subpath_from("../Documents")    # None
			```
		"""
		self._validate()
		if not isinstance(origin, GPath):
			origin = GPath(origin)

		if origin._absolute:
			common = GPath.find_common(self, origin)
			if common is None:
				return None

			new_path = GPath()
			new_path._parent = len(origin) - len(common)
			new_path._parts = self._parts[len(common):]
			return new_path

		else:
			common = GPath.find_common(self, origin, allow_current=True, allow_parents=True)
			if common is None:
				return None
			if common._parent > self._parent:
				return None  # Path from common to self's parent cannot be known

			# common._dotdot == self._dotdot
			# origin._dotdot <= self._dotdot

			new_path = GPath()
			if len(common) == 0:
				if origin._parent == self._parent:
					new_path._parent = len(origin)
				else:
					new_path._parent = (common._parent - origin._parent) + len(origin)
				new_path._parts = self._parts
			else:
				new_path._parent = len(origin) - len(common)
				new_path._parts = self._parts[len(common):]

			return new_path


	def __hash__(self) -> int:
		"""
			Calculate hash of the GPath object.

			Usage: <code>hash(<var>g</var>)</code>
		"""
		return hash((tuple(self._parts), self._device, self._absolute, self._parent))


	def __eq__(self, other: Any) -> bool:
		"""
			Check if two GPaths are completely identical.

			Always return False if `other` is not a GPath object, even if it is a GPath-like object.

			Usage: <code><var>g1</var> == <var>g2</var></code>

			Examples
			--------
			```python
			GPath("/usr/bin") == GPath("/usr/bin")  # True
			GPath("/usr/bin") == GPath("usr/bin")   # False
			GPath("C:/") == GPath("D:/")            # False
			GPath("/usr/bin") == "/usr/bin"         # False
			```
		"""
		if isinstance(other, GPath):
			return ((self._absolute, self._device, self._parent) + self._parts) == ((other._absolute, other._device, other._parent) + other._parts)
		else:
			return False


	def __lt__(self, other: GPathLike) -> bool:
		"""
			Check if `self` should be collated before `other` by comparing them in component-wise lexicographical order.

			Absolute paths come before (is less than) parent relative paths, which come before (is less than) non-parent relative paths. Between two parent relative paths, the path with the higher parent level comes first (is lesser).

			Usage: <code><var>self</var> < <var>other</var></code>

			Examples
			--------
			```python
			GPath("/") < GPath("C:/")      # True
			GPath("C:/") < GPath("../..")  # True
			GPath("../..") < GPath("..")   # True
			GPath("..") < GPath("")        # True
			GPath("/") < GPath("/usr")     # True
			```
		"""
		if not isinstance(other, GPath):
			other = GPath(other)
		return ((not self._absolute, self._device, -1 * self._parent) + self._parts) < ((not other._absolute, other._device, -1 * other._parent) + other._parts)


	def __bool__(self) -> bool:
		"""
			Truthy if `self` is an absolute path, if `self` is relative to a parent directory, or if `self` has at least one named component.

			Usage: <code>bool(<var>g</var>)</code>, <code>not <var>g</var></code>, or <code>if <var>g</var>:</code>

			Examples
			--------
			```python
			bool(GPath("/"))    # True
			bool(GPath(".."))   # True
			bool(GPath("doc"))  # True
			bool(GPath(""))     # False
			```
		"""
		return self._absolute or self._parent != 0 or len(self._parts) > 0


	def __str__(self) -> str:
		"""
			Return a string representation of the path.

			Usage: <code>str(<var>g</var>)</code>
		"""
		return GPath.separator.join(self.get_parts())


	def __repr__(self) -> str:
		"""
			Return a string that, when printed, gives the Python code associated with instantiating the GPath object.

			Usage: <code>repr(<var>g</var>)</code>
		"""
		if bool(self):
			return f"GPath({repr(str(self))})"
		else:
			return f"GPath({repr('')})"


	def __len__(self) -> int:
		"""
			Get the number of named path components, excluding any device name or parent directories.

			Usage: <code>len(<var>g</var>)</code>

			Examples
			--------
			```python
			len(GPath("/usr/bin"))   # 2
			len(GPath("/"))          # 0
			len(GPath("C:/Windows))  # 0
			len(GPath("C:/))         # 0
			```
		"""
		return len(self._parts)


	def __getitem__(self, index: Union[int, slice]) -> Union[str, list[str]]:
		"""
			Get a 0-indexed named path component, or a slice of path components, excluding any device name or parent directories.

			Usage: <code><var>g</var>[<var>n</var>]</code>, <code><var>g</var>[<var>start</var>:<var>end</var>]</code>, <code><var>g</var>[<var>start</var>:<var>end</var>:<var>step</var>]</code>, etc.

			Examples
			--------
			```python
			GPath("/usr/local/bin")[1]    # "local"
			GPath("/usr/local/bin")[-1]   # "bin"
			GPath("/usr/local/bin")[1:]   # ["local", "bin"]
			GPath("/usr/local/bin")[::2]  # ["usr", "bin"]
			```
		"""
		if isinstance(index, int):
			return self._parts[index]
		elif isinstance(index, slice):
			return list(self._parts[index])


	def __iter__(self) -> Iterator[str]:
		"""
			Get an iterator through the named path components, excluding any device name or parent directories.

			Usage: <code>iter(<var>g</var>)</code> or <code>for <var>p</var> in <var>g</var>:</code>
		"""
		return iter(self._parts)


	def __contains__(self, other: GPathLike) -> bool:
		"""
			Check if the path represented by `self` contains the path represented by `other`; i.e. check if `self` is a parent directory of `other`.

			Usage: <code><var>other</var> in <var>self</var></code>

			Raises `ValueError` if either GPath is invalid

			Examples
			--------
			```python
			GPath("/usr/local/bin") in GPath("/usr")  # True
			GPath("/usr/local/bin") in GPath("/bin")  # False
			GPath("..") in GPath("../..")             # True
			GPath("..") in GPath("C:/")               # False
			```
		"""
		if not isinstance(other, GPath):
			other = GPath(other)

		common_path = GPath.find_common(self, other, allow_current=True, allow_parents=True)
		return common_path is not None and common_path == self


	def __add__(self, other: GPathLike) -> GPath:
		"""
			Add (concatenate) `other` to the end of `self` if `other` is a relative path, and return a new copy.

			If `other` is an absolute path, or if `other` has a different device name, return an unchanged copy of `self`.

			Alias: `__div__()`

			Usage: <code><var>self</var> + <var>other</var></code> or <code><var>self</var> / <var>other</var></code>

			Raises `ValueError` if either GPath is invalid

			Examples
			--------
			```python
			GPath("/usr") + GPath("local/bin")                   # GPath("/usr/local/bin")
			GPath("C:/Windows/System32") + GPath("../SysWOW64")  # GPath("C:/Windows/SysWOW64")
			GPath("..") + GPath("../..")                         # GPath("../../..")
			GPath("..") / GPath("../..")                         # GPath("../../..")
			```
		"""
		if isinstance(other, GPath):
			other._validate
		else:
			other = GPath(other)

		if other._absolute:
			return GPath(self)
		elif other._device != None and other._device != "" and self._device != other._device:
			return GPath(self)
		else:
			new_path = GPath(self)
			new_parts = [part for part in self._parts]
			for i in range(other._parent):
				if len(new_parts) > 0:
					new_parts.pop()
				elif not new_path._absolute:
					new_path._parent += 1
				else:
					pass  # parent of directory of root is still root

			new_parts.extend(other._parts)
			new_path._parts = tuple(new_parts)
			return new_path


	def __sub__(self, n: int) -> GPath:
		"""
			Remove `n` components from the end of the path and return a new copy.

			Usage: <code><var>self</var> - <var>n</var></code>

			Raises `ValueError` if `self` is an invalid GPath or if `n` is negative

			Examples
			--------
			```python
			GPath("C:/Windows/System32") - 1  # GPath("C:/Windows")
			GPath("/usr/bin") - 2             # GPath("/")
			GPath("Documents") - 3            # GPath("..")
			GPath("/") - 1                    # GPath("/")
			```
		"""
		if n < 0:
			raise ValueError("cannot subtract a negative number of components from the path; use __add__() instead")

		new_path = GPath(self)
		new_parts = [part for part in self._parts]
		for i in range(n):
			if len(new_parts) > 0:
				new_parts.pop()
			elif not new_path._absolute:
				new_path._parent += 1
			else:
				pass  # removing components from root should still give root
		new_path._parts = tuple(new_parts)
		return new_path


	def __mul__(self, n: int) -> GPath:
		"""
			Duplicate the named components of `self` `n` times and return a new path with the duplicated components.

			Named components will be duplicated separately from the components representing a parent directory. If `self` is an absolute path, only the relative components will be duplicated.

			If `n` is 0, the result is an empty path (either relative or absolute).

			Usage: <code><var>self</var> * <var>n</var></code>

			Raises `ValueError` if `self` is an invalid GPath or if `n` is negative.

			Examples
			--------
			```python
			GPath("/usr/bin") * 2    # GPath("/usr/bin/usr/bin")
			GPath("../docs") * 2     # GPath("../../docs/docs")
			GPath("C:/Windows") * 0  # GPath("C:/")
			```
		"""
		if n < 0:
			raise ValueError("cannot multiply path by a negative integer")
		new_path = GPath(self)
		new_path._parent = self._parent * n
		new_path._parts = self._parts * n
		return new_path


	def __div__(self, other: GPathLike) -> GPath:
		"""
			Alias of `__add__()`.
		"""
		return self.__add__(other)


	def __lshift__(self, n: int) -> GPath:
		"""
			Move the imaginary current working directory `n` steps up the filesystem tree.

			If `self` is a relative path, remove up to `n` levels of parent directories from the start of the path and return a copy. If it is an absolute path, return a copy of `self` unchanged.

			If `n` is negative, this is equivalent to `__rshift__(-n)`.

			Usage: <code><var>self</var> << <var>n</var></code>

			Raises `ValueError` if `self` is an invalid GPath.

			Examples
			--------
			```python
			GPath("../SysWOW64/drivers") << 1  # GPath("SysWOW64/drivers")
			GPath("../doc") << 2               # GPath("doc")
			GPath("/usr/bin") << 2             # GPath("/usr/bin")
			```
		"""
		if n < 0:
			return self.__rshift__(-1 * n)
		new_path = GPath(self)
		if not new_path._absolute:
			new_path._parent = max(new_path._parent - n, 0)
		return new_path


	def __rshift__(self, n: int) -> GPath:
		"""
			Move the imaginary current working directory `n` steps down the filesystem tree.

			If `self` is a relative path, add `n` levels of parent directories to the start of the path and return a copy. If it is an absolute path, return a copy of `self` unchanged.

			If `n` is negative, this is equivalent to `__lshift__(-n)`.

			Usage: <code><var>self</var> >> <var>n</var></code>

			Raises `ValueError` if `self` is an invalid GPath

			Examples
			--------
			```python
			GPath("../SysWOW64/drivers") >> 1  # GPath("../../SysWOW64/drivers")
			GPath("/usr/bin") >> 2             # GPath("/usr/bin")
			```
		"""
		if n < 0:
			return self.__lshift__(-1 * n)
		new_path = GPath(self)
		if not new_path._absolute:
			new_path._parent += n
		return new_path

	def _validate(self) -> bool:
		# Check if self is in a valid state
		if self._parent < 0:
			raise ValueError(f"invalid GPath, _parent cannot be negative: {repr(self)}")
		if self._absolute:
			if self._parent != 0:
				raise ValueError(f"invalid GPath, _parent must be 0 when root is True: {repr(self)}")
		else:
			if self._device != "" and self._device is not None:
				raise ValueError(f"invalid GPath, _device must be unset when root is False: {repr(self)}")
		return True


GPathLike = Union[GPath, PathLike]
"""Union type of GPath-like objects that can be used as the argument for most GPath methods."""
